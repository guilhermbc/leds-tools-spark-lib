"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclareDocsOrder = void 0;
const Enums_js_1 = require("../shared/Enums.js");
class DeclareDocsOrder {
    constructor(first, last) {
        this.first = first;
        this.last = last;
    }
    toString() {
        return `${this.first}\n${this.last}`;
    }
}
exports.DeclareDocsOrder = DeclareDocsOrder;
class SintaxeAbstraction {
    constructor(extension, codeBlock, endline = ";") {
        this.extension = extension;
        this.codeBlock = codeBlock;
        this.endline = endline;
    }
    endlineLn(identation) {
        return `${this.endline}\n${'\t'.repeat(identation)}`;
    }
    declareClass(clazz, identation = 0) {
        return `${'\t'.repeat(identation)}${this.declareClassSignature(clazz)}${this.codeBlock.start}\n${this.declareClassBody(clazz, identation + 1)}${this.codeBlock.end}`;
    }
    declareClassBody(clazz, identantion) {
        return `${this.declareClassAttributes(clazz.getAttributes(), identantion)}\n${'\t'.repeat(identantion)}${'\t'.repeat(identantion)}${this.declareConstructor(clazz)}\n${this.declareClassMethods(clazz.getMethods(), identantion)}`;
    }
    declareClassAttributes(attrs, identantion) {
        return attrs.map(attr => this.declareAttribute(attr)).join(this.endlineLn(identantion));
    }
    declareClassMethods(methods, identantion) {
        return methods.map(method => this.defineMethod(method)).join(this.endlineLn(identantion));
    }
    declareClassSignature(clazz) {
        switch (clazz.getModifier()) {
            case Enums_js_1.ModifierOptions.ABSTRACT:
                return this.declareWithDocs(this.declareAbstractClass(clazz), this.declareClassDocs(clazz)).toString();
            case Enums_js_1.ModifierOptions.STATIC:
                return this.declareWithDocs(this.declareStaticClass(clazz), this.declareClassDocs(clazz)).toString();
            case Enums_js_1.ModifierOptions.CONCRETE:
                return this.declareWithDocs(this.declarePhysicalClass(clazz), this.declareClassDocs(clazz)).toString();
        }
    }
    defineMethod(method) {
        switch (method.getOption()) {
            case Enums_js_1.ModifierOptions.ABSTRACT:
                return this.declareWithDocs(this.declareAbstractMethod(method), this.declareMethodDocs(method)).toString();
            case Enums_js_1.ModifierOptions.STATIC:
                return this.declareWithDocs(this.declareStaticMethod(method), this.declareMethodDocs(method)).toString();
            case Enums_js_1.ModifierOptions.CONCRETE:
                return this.declareWithDocs(this.declarePhysicalMethod(method), this.declareMethodDocs(method)).toString();
        }
    }
}
exports.default = SintaxeAbstraction;
