"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vueModularArchProjectSettings = void 0;
const FolderAbstraction_1 = __importDefault(require("../../../abstractions/project/FolderAbstraction"));
const PrimitiveTypeAbstraction_1 = __importDefault(require("../../../abstractions/types/PrimitiveTypeAbstraction"));
const TSClass_1 = require("./TSClass");
const TSProject_1 = require("./TSProject");
const TSSintaxe_1 = require("./TSSintaxe");
const TSTypes_1 = require("./TSTypes");
const TSVariables_1 = require("./TSVariables");
class CreateReq extends TSVariables_1.TypeScriptArggument {
    constructor(clazz) {
        super(clazz.getName(), new PrimitiveTypeAbstraction_1.default(`${clazz.getName()}CreateReq`), "");
    }
}
const idArgument = new TSVariables_1.TypeScriptArggument("Id", new TSTypes_1.TypescriptString(), "");
class ActionBaseMethod extends TSClass_1.TypescriptMethod {
    constructor(name, argguments, action, httpMethod, args) {
        super("async", argguments, new TSTypes_1.TypescriptPromisseAny(), undefined, undefined);
        this.entityName = name;
        this.actionName = action;
        this.axiosname = httpMethod;
        this.args = args;
    }
    getbody() {
        return [`return await adminapi.${this.actionName}<${this.entityName}${this.actionName}Res>('/'${this.args}, ${this.entityName}ReqConf);`];
    }
}
class ListarConstrain extends TSProject_1.TypescriptConstrains {
    constructor(clazz) {
        super(`listar${clazz.getName()}`, null, true, new ActionBaseMethod(clazz.getName(), [], "List", "get", ""));
    }
}
class CriarConstrain extends TSProject_1.TypescriptConstrains {
    constructor(clazz) {
        super(`criar${clazz.getName()}`, null, true, new ActionBaseMethod(clazz.getName(), [], "Create", "post", `${clazz.getName()}`));
    }
}
class ObterConstrain extends TSProject_1.TypescriptConstrains {
    constructor(clazz) {
        super(`criar${clazz.getName()}`, null, true, new ActionBaseMethod(clazz.getName(), [], "Get", "get", `+ id`));
    }
}
class AtualizarConstrain extends TSProject_1.TypescriptConstrains {
    constructor(clazz) {
        super(`atualizar${clazz.getName()}`, null, true, new ActionBaseMethod(clazz.getName(), [], "Update", "put", `+ ${clazz.getName()}.id, ${clazz.getName()}`));
    }
}
class ExcluirConstrain extends TSProject_1.TypescriptConstrains {
    constructor(clazz) {
        super(`excluir${clazz.getName()}`, null, true, new ActionBaseMethod(clazz.getName(), [], "Update", "put", `+ id`));
    }
}
class VueModularArchitecture {
    implement(modelPackages) {
        let src = new FolderAbstraction_1.default("src", []);
        let module = new FolderAbstraction_1.default("modules", []);
        let modules = modelPackages.map(pkg => new FolderAbstraction_1.default(pkg.getName(), this.buildModule(pkg)));
        modules.forEach(folder => module.addSubfolder(folder));
        src.addSubfolder(module);
        return [src];
    }
    buildModule(pkg) {
        let api = this.buildApiFolder(pkg);
        let controller = this.buildController(pkg);
        let routes = this.buildRoutes(pkg);
        let types = this.buildTypes(pkg);
        return [api, controller, routes, types];
    }
    buildApiFolder(pgk) {
        let folder = new FolderAbstraction_1.default("api");
        let files = pgk.getPackageLevelClasses().map(clazz => new TSProject_1.TypescriptFile(clazz.getName(), `
import adminApi, { adminApiConfig } from '@/api/admin'
import type {
  ${clazz.getName()},
  ${clazz.getName()}CreateReq,
  ${clazz.getName()}ListRes,
  ${clazz.getName()}CreateRes,
  ${clazz.getName()}GetRes,
  ${clazz.getName()}UpdateRes,
  ${clazz.getName()}DeleteRes,
} from '../types/${clazz.getName()}.d.ts'

const ${clazz.getName()}ReqConf = {
  baseURL: adminApiConfig.baseURL + '${clazz.getName()}',
}

export const listar${clazz.getName()} = async () => {
  return await adminApi.get<${clazz.getName()}ListRes>('/', ${clazz.getName()}ReqConf)
}

export const criar${clazz.getName()} = async (${clazz.getName()}: ${clazz.getName()}CreateReq) => {
  return await adminApi.post<${clazz.getName()}CreateRes>('/', ${clazz.getName()}, ${clazz.getName()}ReqConf)
}

export const obter${clazz.getName()} = async (id: string) => {
  const { data } = await adminApi.get<${clazz.getName()}GetRes>('/' + id, ${clazz.getName()}ReqConf)
  return data.value[0]
}

export const atualizar${clazz.getName()} = async (${clazz.getName()}: ${clazz.getName()}) => {
  return await adminApi.put<${clazz.getName()}UpdateRes>('/' + ${clazz.getName()}.Id, ${clazz.getName()}, ${clazz.getName()}ReqConf)
}

export const excluir${clazz.getName()} = async (id: string) => {
  return await adminApi.delete<${clazz.getName()}DeleteRes>('/' + id, ${clazz.getName()}ReqConf)
}
        `, [], TSSintaxe_1.typescriptSintaxe, []));
        files.forEach(file => folder.addFile(file));
        return folder;
    }
    buildController(pkg) {
        let folder = new FolderAbstraction_1.default("controller");
        let files = pkg.getPackageLevelClasses().map(clazz => new TSProject_1.TypescriptFile(clazz.getName(), `import {
  criar${clazz.getName()} as _criar${clazz.getName()},
  listar${clazz.getName()} as _listar${clazz.getName()},
  obter${clazz.getName()} as _obter${clazz.getName()},
  atualizar${clazz.getName()} as _atualizar${clazz.getName()},
  excluir${clazz.getName()} as _excluir${clazz.getName()},
} from '../api/${clazz.getName()}'
import type { ${clazz.getName()}, ${clazz.getName()}CreateReq } from '../types/${clazz.getName()}'
import { useUiStore } from '@/stores/ui'
import { AxiosError } from 'axios'

export const listar${clazz.getName()} = async () => {
  try {
    const { data } = await _listar${clazz.getName()}()
    return data.value
  } catch (error) {
    throw error
  }
}

export const criar${clazz.getName()} = async (${clazz.getName()}: ${clazz.getName()}CreateReq) => {
  const ui = useUiStore()

  try {
    const { data } = await _criar${clazz.getName()}(${clazz.getName()})

    ui.exibirAlerta({
      text: data.message,
      color: 'success'
    })

    return true

  } catch (error) {
    if (
      error instanceof AxiosError &&
      error.response?.status === 400 &&
      error.response.data.errors
    ) {
      ui.exibirAlertas(
        error.response.data.errors
          .map((err: { mensagem: string }) => ({ text: err.mensagem, color: 'error' }))
      )

      return false

    } else {
      throw error
    }
  }
}

export const obter${clazz.getName()} = async (id: string) => {
  try {
    const data = await _obter${clazz.getName()}(id)
    return data
  } catch (error) {
    throw error
  }
}

export const atualizar${clazz.getName()} = async (${clazz.getName()}: ${clazz.getName()}) => {
  try {
    const { data } = await _atualizar${clazz.getName()}(${clazz.getName()})
    return true
  } catch (error) {
    throw error
  }
}

export const excluir${clazz.getName()} = async (id: string) => {
  try {
    const { data } = await _excluir${clazz.getName()}(id)
    return true
  } catch (error) {
    throw error
  }
}

export const excluir${clazz.getName()}s = async (ids: string[]) => {
  try {
    for (const id of ids) {
      const sucesso = await excluir${clazz.getName()}(id)
    }
    return true
  } catch (error) {
    throw error
  }
}`, [], TSSintaxe_1.typescriptSintaxe, []));
        files.forEach(file => folder.addFile(file));
        return folder;
    }
    buildRoutes(pkg) {
        let folder = new FolderAbstraction_1.default("routes");
        let files = pkg.getPackageLevelClasses().map(clazz => new TSProject_1.TypescriptFile("index", `
import type { RouteRecordRaw } from 'vue-router'
import Listar from '../views/Listar.vue'
import Criar from '../views/Criar.vue'

export const routes: RouteRecordRaw[] = [
  {
    name: '${clazz.getName()}-home',
    path: 'home',
    component: Listar,
  },
  {
    name: '${clazz.getName()}-criar',
    path: 'criar/:id?',
    component: Criar,
  }
]
            `, [], TSSintaxe_1.typescriptSintaxe, []));
        files.forEach(file => folder.addFile(file));
        return folder;
    }
    buildTypes(pkg) {
        let folder = new FolderAbstraction_1.default("types");
        let files = pkg.getPackageLevelClasses().map(clazz => new TSProject_1.TypescriptFile(`${clazz.getName()}.d`, `
export type ${clazz.getName()} = {

        ${clazz.getAttributes().map(attr => `${attr.getName()}: ${attr.getType().getName()}`).join("\n\t")}
  Id : string
}

export type ${clazz.getName()}CreateReq = Pick<${clazz.getName()}, ${clazz.getAttributes().map(attr => `"${attr.getName()}"`).join(" | ")}>


export type ${clazz.getName()}ListRes = {
  "@odata.context": string
  value: ${clazz.getName()}[]
}

export type ${clazz.getName()}CreateRes = {
  statusCode: number
  uri: string
  message: string
}

export type ${clazz.getName()}GetRes = ${clazz.getName()}ListRes


export type ${clazz.getName()}UpdateRes = {
  statusCode: number
  message: string
}

export type ${clazz.getName()}DeleteRes = ${clazz.getName()}UpdateRes
            `, [], TSSintaxe_1.typescriptSintaxe, []));
        files.forEach(file => folder.addFile(file));
        return folder;
    }
}
exports.default = VueModularArchitecture;
exports.vueModularArchProjectSettings = {
    architecture: new VueModularArchitecture(),
    lenguage: TSSintaxe_1.typescriptSintaxe
};
