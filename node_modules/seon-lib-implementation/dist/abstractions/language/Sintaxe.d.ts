import ClassAbstraction from "../oo/ClassAbstraction";
import MethodAbstraction from "../oo/MethodAbstraction";
import ArggumentAbstraction from "../types/ArggumentAbstraction";
import AttributeAbstraction from "../types/AttributeAbstraction";
export declare class ClassImplementationConfigOrder {
    private func;
    private separator;
    constructor(func: (param: ClassAbstraction | AttributeAbstraction | ArggumentAbstraction | MethodAbstraction) => string, separator?: string);
    call(param: ClassAbstraction | AttributeAbstraction | ArggumentAbstraction | MethodAbstraction): string;
}
export interface ClassImplementation {
    classKeyword(clazz: ClassAbstraction): string;
    className(clazz: ClassAbstraction): string;
    classVisibility(clazz: ClassAbstraction): string;
    classModifier(clazz: ClassAbstraction): string;
    attrVisibility(attr: AttributeAbstraction): string;
    attrModifier(attr: AttributeAbstraction): string;
    attrName(attr: AttributeAbstraction): string;
    attrType(attr: AttributeAbstraction): string;
    attrDefaultValue(attr: AttributeAbstraction): string;
    constructorVisibility(clazz: ClassAbstraction): string;
    constructorKeyword(clazz: ClassAbstraction): string;
    argumentName(arg: ArggumentAbstraction): string;
    argumentType(arg: ArggumentAbstraction): string;
    argumentDefaultValue(arg: ArggumentAbstraction): string;
    methodKeyword(method: MethodAbstraction): string;
    methodVisibility(method: MethodAbstraction): string;
    methodModifier(method: MethodAbstraction): string;
    methodName(method: MethodAbstraction): string;
    methodReturn(method: MethodAbstraction): string;
}
export declare abstract class ClassImplementationOrder {
    protected clazz: ClassImplementation | null;
    constructor(clazz?: ClassImplementation | null);
    setClass(clazz: ClassImplementation): void;
    abstract getDeclarationOrder(): ClassImplementationConfigOrder[];
    abstract getAttributeDeclarationOrder(): ClassImplementationConfigOrder[];
    abstract getConstructorDeclarationOrder(): ClassImplementationConfigOrder[];
    abstract getArggumentDeclarationOrder(): ClassImplementationConfigOrder[];
    abstract getMethodsDeclarationOrder(): ClassImplementationConfigOrder[];
    abstract getMehodEmptyBody(): string;
}
export interface ConstructorData {
    declaration: string;
    arguments: string[];
    body: string[];
}
export interface MethodsData {
    declaration: string;
    arguments: string[];
    body: string[];
}
export interface ClazzData {
    declaration: string;
    attributes: string[];
    _constructor: ConstructorData;
    methods: MethodsData[];
}
export interface SintaxeReservedData {
    startCodeBlock: string;
    endCodeBlock: string;
    endLineCode: string;
    startArgDeclaration: string;
    endArgDeclaraion: string;
    separeArgDeclaraion: string;
    classReference: string;
    classSubAccess: string;
}
export interface FileExtensionData {
    main: string;
    others?: string[];
}
export default class Sintaxe {
    private clsImpl;
    readonly reserverData: SintaxeReservedData;
    readonly fileExtensions: FileExtensionData;
    constructor(clsImpl: ClassImplementationOrder, reservedData: SintaxeReservedData, fileExtensios: FileExtensionData);
    buildClassData(clazz: ClassAbstraction): ClazzData;
    private declareClass;
    private declareClassAttrs;
    private declareClassAttr;
    private declareClassConstructor;
    private decalreArggument;
    private defineClassAttr;
    private defineClassMethods;
    defineClassMethod(method: MethodAbstraction): MethodsData;
}
